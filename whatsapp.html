<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Super Chat Web</title>
<style>
:root{
  --bg-light:#e5ddd5; --bg-dark:#121212;
  --sidebar-light:#fff; --sidebar-dark:#1e1e1e;
  --text-light:#000; --text-dark:#fff;
  --accent:#25d366;
  --sent:#dcf8c6; --received:#fff;
}

/* Body & Dark Mode */
body{
  margin:0; font-family:'Segoe UI',sans-serif;
  background:var(--bg-light); color:var(--text-light);
  transition:0.3s;
}
body.dark{ background:var(--bg-dark); color:var(--text-dark); }

/* Login screen */
#login-screen{
  display:flex; justify-content:center; align-items:center; height:100vh;
}
#login-box{
  background:var(--sidebar-light); padding:30px 25px; border-radius:12px;
  box-shadow:0 6px 20px rgba(0,0,0,0.1); width:320px; text-align:center;
  transition:0.3s;
}
body.dark #login-box{ background:var(--sidebar-dark); }
#login-box h2{ color:var(--accent); margin-bottom:18px; }
#login-box input{
  width:100%; padding:12px; margin:8px 0; border-radius:8px;
  border:1px solid #ccc; outline:none; background:var(--bg-light); color:var(--text-light);
}
body.dark #login-box input{ background:#333; color:#fff; border-color:#555; }
#login-box button{
  width:100%; padding:12px; margin-top:10px; background:var(--accent);
  color:white; border:none; border-radius:8px; cursor:pointer; font-weight:600;
}
#toggle-auth{ margin-top:10px; color:var(--accent); cursor:pointer; font-size:.9rem; }

/* Main layout */
#main-app{ display:flex; height:100vh; display:none; }

/* Sidebar */
#sidebar{
  width:320px; display:flex; flex-direction:column;
  background:var(--sidebar-light); border-right:1px solid #ccc;
  transition:0.3s;
}
body.dark #sidebar{ background:var(--sidebar-dark); border-color:#333; }

#sidebar header{
  font-weight:bold; padding:15px; border-bottom:1px solid #ccc;
}
body.dark #sidebar header{ border-color:#333; }

#chat-search{
  padding:10px 15px; border-bottom:1px solid #ccc;
}
body.dark #chat-search{ border-color:#333; }

#chat-search input{
  width:100%; padding:8px 12px; border-radius:20px; border:1px solid #ccc;
  outline:none;
}
body.dark #chat-search input{ background:#333; border-color:#555; color:#fff; }

#chat-list{
  flex:1; overflow-y:auto;
}
.chat-item{
  padding:12px 16px; border-bottom:1px solid #ddd; cursor:pointer;
  transition:0.2s;
}
.chat-item:hover{ background:#f6f6f6; }
body.dark .chat-item:hover{ background:#333; }

#sidebar-bottom{
  display:flex; justify-content:space-between; align-items:center;
  padding:10px 15px; border-top:1px solid #ccc;
}
body.dark #sidebar-bottom{ border-color:#333; }
#theme-btn{ background:none; border:none; font-size:22px; cursor:pointer; color:inherit; }
#add-chat-btn{
  background:var(--accent); border:none; color:#fff; padding:5px 12px;
  border-radius:20px; cursor:pointer; font-weight:bold;
}

/* Chat area */
#chat-area{
  flex:1; display:flex; flex-direction:column;
  background:var(--bg-light);
  transition:0.3s;
}
body.dark #chat-area{ background:var(--bg-dark); }

#chat-header{
  padding:15px; border-bottom:1px solid #ccc; font-weight:bold;
  display:flex; justify-content:space-between; align-items:center;
}
body.dark #chat-header{ border-color:#333; }
#chat-header button{ background:none; border:none; cursor:pointer; font-size:18px; }

/* Messages */
#messages{
  flex:1; padding:15px; overflow-y:auto; display:flex; flex-direction:column;
  gap:6px;
}

.message{
  max-width:60%; padding:8px 12px; border-radius:8px; font-size:14px; line-height:1.3;
  position:relative; word-break:break-word;
}
.sent{ background:var(--sent); align-self:flex-end; border-bottom-right-radius:2px; }
.received{ background:var(--received); align-self:flex-start; border-bottom-left-radius:2px; }
.timestamp{
  font-size:10px; color:gray; position:absolute; bottom:-12px; right:6px;
}

/* Message input */
#message-input{
  display:flex; border-top:1px solid #ccc; padding:10px;
}
body.dark #message-input{ border-color:#333; }
#message-input input{
  flex:1; padding:10px; border:none; border-radius:20px; outline:none;
}
#message-input button{
  margin-left:10px; width:40px; height:40px; border-radius:50%;
  border:none; background:var(--accent); color:#fff; cursor:pointer;
}

/* Video call overlay */
#video-container{
  display:none; position:absolute; top:20px; right:20px;
  width:300px; background:#000; border-radius:12px; padding:8px; z-index:1000; display:flex; flex-direction:column; gap:8px;
}
#video-container video{
  width:100%; border-radius:8px; background:#111;
}
#end-call-btn{
  background:red; color:#fff; border:none; border-radius:8px; padding:6px; cursor:pointer;
}

/* Incoming call popup */
#incoming-call{
  display:none; position:fixed; left:50%; top:30%; transform:translateX(-50%); z-index:2000;
  background:var(--sidebar-light); padding:18px; border-radius:10px; box-shadow:0 8px 30px rgba(0,0,0,0.2);
}
body.dark #incoming-call{ background:var(--sidebar-dark); color:var(--text-dark); }
#incoming-call p{ margin:0 0 10px 0; font-weight:600; }
#incoming-call button{ margin-right:8px; padding:8px 12px; border-radius:8px; border:none; cursor:pointer; }
#accept-btn{ background:var(--accent); color:#fff; }
#reject-btn{ background:#e74c3c; color:#fff; }
</style>
</head>
<body>

<!-- Login/Register -->
<div id="login-screen">
  <div id="login-box">
    <h2 id="auth-title">Login</h2>
    <input id="email" type="email" placeholder="Email">
    <input id="password" type="password" placeholder="Password">
    <button id="auth-btn">Login</button>
    <div id="toggle-auth">Don't have an account? Register</div>
  </div>
</div>

<!-- Main App -->
<div id="main-app">
  <div id="sidebar">
    <header>Chats</header>
    <div id="chat-search"><input type="text" placeholder="Search chats..."></div>
    <div id="chat-list"></div>
    <div id="sidebar-bottom">
      <button id="add-chat-btn">+ New Chat</button>
      <button id="theme-btn">🌙</button>
    </div>
  </div>
  <div id="chat-area">
    <div id="chat-header">
      <span id="chat-name">Select a chat</span>
      <div>
        <button id="call-btn">📞</button>
      </div>
    </div>
    <div id="messages"></div>
    <div id="message-input">
      <input type="text" placeholder="Type a message...">
      <button>➤</button>
    </div>
    <div id="video-container">
      <video id="localVideo" autoplay muted></video>
      <video id="remoteVideo" autoplay></video>
      <div style="display:flex; gap:8px; justify-content:flex-end;">
        <button id="end-call-btn">End Call</button>
      </div>
    </div>
  </div>
</div>

<!-- Incoming call popup -->
<div id="incoming-call">
  <p id="incoming-text">Incoming call</p>
  <div>
    <button id="accept-btn">Accept</button>
    <button id="reject-btn">Reject</button>
  </div>
</div>

<script type="module">
// Firebase & Firestore imports
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import {
  getFirestore, collection, addDoc, query, orderBy, where, onSnapshot, serverTimestamp,
  doc, getDoc, updateDoc, setDoc, deleteDoc, getDocs
} from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";
import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";

const firebaseConfig = {
  apiKey:"AIzaSyBME9hUHxXwiVdKB92NgOelfzN1vDmiIqM",
  authDomain:"bruh-8dc71.firebaseapp.com",
  projectId:"bruh-8dc71",
  storageBucket:"bruh-8dc71.appspot.com",
  messagingSenderId:"1056319290667",
  appId:"1:1056319290667:web:86ff76266907bb9af7d96e"
};
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);
const auth = getAuth(app);

// UI Elements
const loginScreen = document.getElementById('login-screen');
const mainApp = document.getElementById('main-app');
const emailInput = document.getElementById('email');
const passwordInput = document.getElementById('password');
const authBtn = document.getElementById('auth-btn');
const toggleAuth = document.getElementById('toggle-auth');
const authTitle = document.getElementById('auth-title');
const chatList = document.getElementById('chat-list');
const chatNameEl = document.getElementById('chat-name');
const messagesEl = document.getElementById('messages');
const themeBtn = document.getElementById('theme-btn');
const addChatBtn = document.getElementById('add-chat-btn');
const callBtn = document.getElementById('call-btn');
const videoContainer = document.getElementById('video-container');
const localVideo = document.getElementById('localVideo');
const remoteVideo = document.getElementById('remoteVideo');
const endCallBtn = document.getElementById('end-call-btn');
const messageInput = document.querySelector('#message-input input');
const sendBtn = document.querySelector('#message-input button');

const incomingCallPopup = document.getElementById('incoming-call');
const incomingText = document.getElementById('incoming-text');
const acceptBtn = document.getElementById('accept-btn');
const rejectBtn = document.getElementById('reject-btn');

let currentUser=null;
let currentChatId=null;
let isRegistering=false;

let pc=null;
let localStream=null;
let remoteStream=null;
let callDocRef=null;
let offerCandidatesUnsub=null;
let answerCandidatesUnsub=null;
let callDocUnsub=null;
let incomingCallUnsub=null;

// Theme toggle
themeBtn.onclick=()=>{
  document.body.classList.toggle('dark');
  themeBtn.textContent=document.body.classList.contains('dark')?'☀️':'🌙';
}

// Auth toggle
toggleAuth.onclick=()=>{
  isRegistering=!isRegistering;
  authTitle.textContent=isRegistering?"Register":"Login";
  authBtn.textContent=isRegistering?"Register":"Login";
  toggleAuth.textContent=isRegistering?"Already have an account? Login":"Don't have an account? Register";
}

// Auth
authBtn.onclick=async()=>{
  try{
    if(isRegistering) await createUserWithEmailAndPassword(auth,emailInput.value,passwordInput.value);
    else await signInWithEmailAndPassword(auth,emailInput.value,passwordInput.value);
  }catch(e){ alert(e.message); }
}

// Auth state
onAuthStateChanged(auth,user=>{
  if(user){
    currentUser=user;
    loginScreen.style.display='none';
    mainApp.style.display='flex';
    loadChatList();
    startIncomingCallListener(); // listen for incoming calls
  }else{
    loginScreen.style.display='flex';
    mainApp.style.display='none';
    stopIncomingCallListener();
  }
});

// Chat List
function loadChatList(){
  if(!currentUser) return;
  const q=query(collection(db,'chats'),where("participants","array-contains",currentUser.email));
  onSnapshot(q,snapshot=>{
    chatList.innerHTML='';
    snapshot.forEach(docSnap=>{
      const chat=docSnap.data();
      const div=document.createElement('div');
      div.className='chat-item';
      div.textContent=chat.name||"Unnamed Chat";
      div.onclick=()=>openChat(docSnap.id,chat.name||"Chat");
      chatList.appendChild(div);
    });
  });
}

// Add chat
addChatBtn.onclick=async()=>{
  const name=prompt("Enter chat name:");
  const participantsStr=prompt("Enter participant emails separated by commas:");
  if(name && participantsStr){
    const participants=participantsStr.split(',').map(p=>p.trim()).filter(Boolean);
    if(!participants.includes(currentUser.email)) participants.push(currentUser.email);
    await addDoc(collection(db,'chats'),{name,participants});
  }
}

// Open chat
function openChat(chatId,name){
  currentChatId=chatId;
  chatNameEl.textContent=name;
  messagesEl.innerHTML='';
  const q=query(collection(db,'chats',chatId,'messages'),orderBy('timestamp'));
  onSnapshot(q,snapshot=>{
    messagesEl.innerHTML='';
    snapshot.forEach(doc=>{
      const msg=doc.data();
      const div=document.createElement('div');
      div.className='message '+(msg.sender===currentUser.email?'sent':'received');
      const time = msg.timestamp?.toDate ? msg.timestamp.toDate().toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'}) : '';
      div.innerHTML=`${escapeHtml(msg.text)}<div class="timestamp">${time}</div>`;
      messagesEl.appendChild(div);
    });
    messagesEl.scrollTop=messagesEl.scrollHeight;
  });
}

// Send message
sendBtn.onclick=async()=>{
  const text=messageInput.value.trim();
  if(text && currentChatId){
    await addDoc(collection(db,'chats',currentChatId,'messages'),{text,sender:currentUser.email,timestamp:serverTimestamp()});
    messageInput.value='';
  }
}

// Simple helper
function escapeHtml(unsafe) {
  return unsafe
       .replaceAll("&", "&amp;")
       .replaceAll("<", "&lt;")
       .replaceAll(">", "&gt;")
       .replaceAll('"', "&quot;")
       .replaceAll("'", "&#039;");
}

// ----------- WebRTC + Firestore signaling (full flow) ------------
const servers={iceServers:[{urls:'stun:stun.l.google.com:19302'}]};

// Caller: create call
callBtn.onclick=async()=>{
  if(!currentChatId){ alert('Select chat first'); return; }
  if(!currentUser){ alert('Not signed in'); return; }

  // Create RTCPeerConnection
  pc = new RTCPeerConnection(servers);
  remoteStream = new MediaStream();
  remoteVideo.srcObject = remoteStream;
  pc.ontrack = e => {
    e.streams[0].getTracks().forEach(t=>{
      // avoid duplicate tracks
      if(!remoteStream.getTracks().some(mt => mt.id === t.id)) remoteStream.addTrack(t);
    });
  };

  // Local stream
  try{
    localStream = await navigator.mediaDevices.getUserMedia({video:true,audio:true});
  }catch(err){ alert('Could not get local media: '+err.message); return; }
  localStream.getTracks().forEach(track=>pc.addTrack(track,localStream));
  localVideo.srcObject = localStream;

  // Prepare Firestore call doc
  callDocRef = doc(collection(db,'calls'));
  const offerCandidatesCol = collection(callDocRef,'offerCandidates');
  const answerCandidatesCol = collection(callDocRef,'answerCandidates');

  // ICE candidate -> offerCandidates
  pc.onicecandidate = event=>{
    if(event.candidate){
      addDoc(offerCandidatesCol, event.candidate.toJSON()).catch(console.error);
    }
  };

  // create offer
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);

  // write call doc
  await setDoc(callDocRef, {
    chatId: currentChatId,
    caller: currentUser.email,
    offer: { type: offer.type, sdp: offer.sdp },
    status: 'ringing',
    createdAt: serverTimestamp()
  });

  // show outgoing UI
  videoContainer.style.display='flex';

  // Listen for answer in call doc
  callDocUnsub = onSnapshot(callDocRef, async snapshot=>{
    const data = snapshot.data();
    if(!data) return;
    // If callee rejected
    if(data.status === 'rejected'){
      alert('Call rejected');
      cleanupCall();
      return;
    }
    // If answer appears, set remote description
    if(data.answer && !pc.currentRemoteDescription){
      const answerDesc = { type: data.answer.type, sdp: data.answer.sdp };
      await pc.setRemoteDescription(answerDesc);
    }
  });

  // Listen for answerCandidates from callee
  answerCandidatesUnsub = onSnapshot(collection(callDocRef,'answerCandidates'), snapshot=>{
    snapshot.docChanges().forEach(change=>{
      if(change.type === 'added'){
        const cand = change.doc.data();
        pc.addIceCandidate(cand).catch(console.error);
      }
    });
  });

  // If callee accepts, they will add candidates to answerCandidates; we also need to watch for cleanup if call doc deleted
  // Also monitor call doc deletion
  // When callDoc is removed, our onSnapshot will get no data (handled above in cleanup path)

  // In case call doc is removed or cleaned-up by callee, listen for deletion:
  // (handled via onSnapshot earlier — if snapshot.exists false, stop)
};

// Incoming call listener: listens for ringing calls for chats the user participates in
function startIncomingCallListener(){
  if(!currentUser) return;
  // Listen to calls collection for calls related to chats where current user is a participant.
  // Simpler approach: listen to calls where status == 'ringing' AND chatId == currentChatId (only notify if you're in that chat)
  // We'll also allow notification for active chat only.
  stopIncomingCallListener();
  incomingCallUnsub = onSnapshot(collection(db,'calls'), snapshot=>{
    snapshot.docChanges().forEach(async change=>{
      if(change.type === 'added' || change.type === 'modified'){
        const data = change.doc.data();
        const id = change.doc.id;
        if(!data) return;
        if(data.status !== 'ringing') return;
        // notify only if the call is for the chat the user currently has open and the caller isn't the current user
        if(data.chatId === currentChatId && data.caller !== currentUser.email){
          // show incoming popup
          incomingText.textContent = `${data.caller} is calling in "${chatNameEl.textContent}"`;
          incomingCallPopup.style.display='block';

          // Save reference to this call doc for accept/reject flow
          // We will attach handlers that refer to this call id
          const callRef = doc(db,'calls', id);

          // Accept handler
          const doAccept = async ()=>{
            incomingCallPopup.style.display='none';
            await answerCall(callRef, data);
          };

          // Reject handler
          const doReject = async ()=>{
            incomingCallPopup.style.display='none';
            try{
              await updateDoc(callRef, { status: 'rejected' });
            }catch(e){ console.error('Reject error', e); }
          };

          // Wire buttons (remove previous handlers by reassigning onclick)
          acceptBtn.onclick = doAccept;
          rejectBtn.onclick = doReject;
        }
      }
    });
  });
}

function stopIncomingCallListener(){
  if(incomingCallUnsub) { incomingCallUnsub(); incomingCallUnsub = null; }
}

// Callee: answer the call
async function answerCall(callRef, callData){
  // Guard
  if(!callData || !callRef) return;

  // Create RTCPeerConnection
  pc = new RTCPeerConnection(servers);
  remoteStream = new MediaStream();
  remoteVideo.srcObject = remoteStream;
  pc.ontrack = e => {
    e.streams[0].getTracks().forEach(t=>{
      if(!remoteStream.getTracks().some(mt => mt.id === t.id)) remoteStream.addTrack(t);
    });
  };

  // ICE candidate -> answerCandidates
  const answerCandidatesCol = collection(callRef,'answerCandidates');
  pc.onicecandidate = event=>{
    if(event.candidate){
      addDoc(answerCandidatesCol, event.candidate.toJSON()).catch(console.error);
    }
  };

  // Get local media
  try{
    localStream = await navigator.mediaDevices.getUserMedia({video:true,audio:true});
  }catch(err){ alert('Could not get local media: '+err.message); return; }
  localStream.getTracks().forEach(track=>pc.addTrack(track,localStream));
  localVideo.srcObject = localStream;
  videoContainer.style.display='flex';

  // Set remote description using offer from callData
  const offerDesc = callData.offer;
  await pc.setRemoteDescription({ type: offerDesc.type, sdp: offerDesc.sdp });

  // Create answer
  const answer = await pc.createAnswer();
  await pc.setLocalDescription(answer);

  // Update call doc with answer and status=connected
  await updateDoc(callRef, {
    answer: { type: answer.type, sdp: answer.sdp },
    status: 'connected',
    answeredAt: serverTimestamp(),
    callee: currentUser.email
  });

  // Listen for offerCandidates added by caller and add to our pc
  offerCandidatesUnsub = onSnapshot(collection(callRef,'offerCandidates'), snapshot=>{
    snapshot.docChanges().forEach(change=>{
      if(change.type === 'added'){
        const cand = change.doc.data();
        pc.addIceCandidate(cand).catch(console.error);
      }
    });
  });

  // Optionally monitor call doc for status changes (ended/rejected)
  callDocUnsub = onSnapshot(callRef, snapshot=>{
    const data = snapshot.data();
    if(!data) return;
    if(data.status === 'ended' || data.status === 'rejected'){
      cleanupCall();
    }
  });
}

// End call (shared)
endCallBtn.onclick = async ()=>{
  if(!callDocRef){
    cleanupCall();
    return;
  }
  try{
    // update status to ended so other peer can cleanup
    await updateDoc(callDocRef, { status: 'ended' });
    // delete candidate collections and call doc (best-effort)
    await cleanupCallDocs(callDocRef);
  }catch(e){ console.warn('Error ending call doc:', e); }
  cleanupCall();
};

// Common cleanup routine (client-side)
async function cleanupCall(){
  // stop subs
  if(offerCandidatesUnsub){ offerCandidatesUnsub(); offerCandidatesUnsub = null; }
  if(answerCandidatesUnsub){ answerCandidatesUnsub(); answerCandidatesUnsub = null; }
  if(callDocUnsub){ callDocUnsub(); callDocUnsub = null; }
  if(callDocRef){ 
    // attempt to delete call doc and its children (best-effort)
    try{ await cleanupCallDocs(callDocRef); }catch(e){ /*ignore*/ }
    callDocRef = null;
  }

  if(pc){ try{ pc.close(); }catch(e){} pc = null; }
  if(localStream){ localStream.getTracks().forEach(t=>t.stop()); localStream = null; localVideo.srcObject = null; }
  if(remoteStream){ remoteStream.getTracks().forEach(t=>t.stop()); remoteStream = null; remoteVideo.srcObject = null; }
  videoContainer.style.display='none';
}

// Delete call doc and its candidate subcollections (best-effort)
async function cleanupCallDocs(callDocRefToDelete){
  try{
    // delete offerCandidates
    const offerCandsSnap = await getDocs(collection(callDocRefToDelete,'offerCandidates'));
    for(const d of offerCandsSnap.docs) await deleteDoc(doc(callDocRefToDelete,'offerCandidates',d.id));
    // delete answerCandidates
    const answerCandsSnap = await getDocs(collection(callDocRefToDelete,'answerCandidates'));
    for(const d of answerCandsSnap.docs) await deleteDoc(doc(callDocRefToDelete,'answerCandidates',d.id));
    // delete call doc
    await deleteDoc(callDocRefToDelete);
  }catch(e){ console.warn('cleanupCallDocs error', e); }
}

// Watch for call documents that relate to a call we created (so caller receives answer & candidates)
// We already set up callDocUnsub inside caller flow to watch the specific callDocRef. For completeness, we also implement a global watcher that if the current user initiated a call earlier (callDocRef is not null) will pick up the answer (handled above).

// Also handle remote party rejecting while caller is waiting: caller listens to callDocUnsub and handles data.status === 'rejected' above.
s
// Extra: When user navigates away or signs out, cleanup any active call state
window.addEventListener('beforeunload', async ()=>{
  try{ await cleanupCall(); }catch(e){}
});

// Also: If user signs out, cleanup
// (We already call stopIncomingCallListener on sign-out via onAuthStateChanged)

// ----------------- End WebRTC section -----------------------
</script>

</body>
</html>